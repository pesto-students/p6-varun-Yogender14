Exercise 1.1

1. When a user enters an URL in the browser, how does the browser fetch the desired result ?
  Explain this with the below in mind and Demonstrate this by drawing a diagram for the same.
  - What is the main functionality of the browser?
  - High level components of a browser.
  - Rendering engine and its uses.
  - Parsers(HTML, CSS , etc)
  - Script processors
  - Tree construction
  - Order of script processing
  - Layout and painting

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
**Answers**
Browser-A web browser is a software application that is used to access the world wide web(www) or as known by everyone on the Internet.
It is an interface between us and the information available on the web

The whole process of gathering information begins with the user when it enters the URL of the desired website in the address bar. The browser is a part of the client-server model
where it plays the part of the client.

there are four layers through which this domain name query goes through. Let’s understand the steps:

1. After hitting the URL, the browser cache is checked. As browser maintains its DNS records for some amount of time for the websites you have visited earlier. 
   Hence, firstly, DNS query runs here to find the IP address associated with the domain name.

2. The second place where DNS query runs in OS cache followed by router cache.

3. If in the above steps, a DNS query does not get resolved, then it takes the help of resolver server. Resolver server is nothing but your ISP
   (Internet service provider). The query is sent to ISP where DNS query runs in ISP cache.

4. If in 3rd steps as well, no results found, then request sends to top or root server of the DNS hierarchy. There it never happens that it says no results found, 
   but actually it tells, from where this information you can get. If you are searching IP address of the top level domain (.com,.net,.Gov,. org). 
   It tells the resolver server to search TLD server (Top level domain).

5. Now, resolver asks TLD server to give IP address of our domain name. TLD stores address information of domain name. It tells the resolver to ask it to Authoritative Name server.

6. The authoritative name server is responsible for knowing everything about the domain name. Finally, resolver (ISP) gets the IP address associated with the domain name and sends it back to the browser.

After getting an IP address, resolver stores it in its cache so that next time, if the same query comes then it does not have to go to all these steps again. It can now provide IP address from their cache.

This is all about the steps that is followed to resolve IP address that is associated with the domain name. Have a look below to better understand:
![image](https://user-images.githubusercontent.com/107746743/174431549-6e310e48-9311-4d93-906c-d6e8394cb537.png)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# - What is the main functionality of the browser?

**The Main fucntion of Browsers.**
The main functionality of a web browser is to locate, retrieve and display content on the World Wide Web, 
including a variety of Web pages, images, video and other files. 
•	Displaying and printing Web contents on the Internet or intranet
•	Displaying, printing, and saving a file on the Internet or intranet
•	Uploading scanned original data (via a server on the Internet or intranet)
•	Uploading a file in a User Box (via a server on the Internet or intranet)
•	Using a file in a User Box of an MFP on the network (via Web Connection)
•	Using dedicated Web browser settings (must be associated with My Panel Manager)


#  - High level components of a browser.


The web browser is made of 7 main components that work in sync to make the web browser function-able. These are-
**1. User Interface**
The user interface is the first page that you see when you open the web browser. This page has the address bar, forward/ backward button, menu, 
bookmarking option, and a few more options.

2. Browser Engine
The browser engine acts as an interface between the rendering engine and the UI of the browser. Based on the input, 
it manipulated the rendering engine to provide output



3. Rendering engine
This component is responsible for rendering a specific web page requested by the user on their screen. It interprets HTML and XML documents along with images that are styled or formatted using CSS, 
and a final layout is generated, which is displayed on the user interface.

4. Networking
The network layer is responsible for security and communication on the internet. It is also used for HTTP requests and to cache the documents retrieved in order
to reduce network traffic.
5. UI Backend
UI backend is used for drawing basic widgets like combo boxes and Windows.it exposes a generic interface that is not platform specific. Underneath it uses operating system user interface methods. 
JavaScript interpreter.It allows conversion of JavaScript code in a document and the executes it. Then the engine shows the translation on the screen to the users.


6. JavaScript Interpreter
As we all know the JavaScript is responsible for all the websites/ webpages. All these pages are written in JavaScript language. 
Therefore this interpreter translates these pages and these are sent to the rendering engine to display the final results.

7. Data persistence
Data persistence or storage is for saving the data locally, like cookies. The browsers support storage mechanisms like IndexedDB, WebSQL, File System, etc. 
to store databases locally on your computer. This way user data is handled like cache, bookmarks, cookies, etc.

![image](https://user-images.githubusercontent.com/107746743/174857954-c913ee6b-bb89-41dc-9205-d9ac737ae0f9.png)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

 # - Rendering engine and its uses.
this component is responsible for rendering a specific web page requested by the user on their screen. It interprets HTML and XML documents along with images that are styled or formatted using CSS, 
and a final layout is generated, which is displayed on the user interface.

Role of Rendering Engine:
Once a user requests a particular document, the rendering engine starts fetching the content of the requested document. This is done via the networking layer.
The rendering engine starts receiving the content of that specific document in chunks of 8 KBs from the networking layer. 
After this, the basic flow of the rendering engine begins.
![image](https://user-images.githubusercontent.com/107746743/174858585-ec2ca3e1-129f-4103-aa60-afb35fee740f.png)


The four basic steps include:

1. The requested HTML page is parsed in chunks, including the external CSS files and in style elements, by the rendering engine. 
The HTML elements are then converted into DOM nodes to form a “content tree” or “DOM tree.”

2. Simultaneously, the browser also creates a render tree. This tree includes both the styling information as well as the visual instructions that define the order in which the elements will be displayed. 
The render tree ensures that the content is displayed in the desired order.

3. Further, the render tree goes through the layout process. When a render tree is created, the position or size values are not assigned. The entire process of calculating values for evaluating the desired position is called a layout process. In this process, 
4. every node is assigned the exact coordinates. This ensures that every node appears at an accurate position on the screen.

5. The final step is to paint the screen, wherein the render tree is traversed, and the renderer’s paint() method is invoked, 
which paints each node on the screen using the UI backend layer.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
# - Parsers(HTML, CSS , etc)

Parsing means analyzing and converting a program into an internal format that a runtime environment can actually run, 
for example the JavaScript engine inside browsers.

 HTML parsing involves tokenization and tree construction. HTML tokens include start and end tags, as well as attribute names and values
 If the document is well-formed, parsing it is straightforward and faster. The parser parses tokenized input into the document, building up the document tree.

 When the browser encounters CSS styles, it parses the text into the CSS Object Model (or CSSOM), a data structure it then uses for styling layouts and painting. 
   The browser then creates a render tree from both these structures to be able to paint the content to the screen. JavaScript is also downloaded, parsed, and then executed.
 ------------------------------------------------------------------------------------------------------------------------------------------------------------------
  # - Script processors

The script processor uses the script cache to avoid recompiling the script for each incoming document. To improve performance, 
ensure the script cache is properly sized before using a script processor in production.

 # - Tree construction
 The DOM tree describes the content of the document. The <html> element is the first tag and root node of the document tree. The tree reflects the relationships and hierarchies between different tags. Tags nested within other tags are child nodes.
  The greater the number of DOM nodes, the longer it takes to construct the DOM tree.
  When the parser finds non-blocking resources, such as an image, the browser will request those resources and continue parsing. Parsing can continue when a CSS file is encountered, but <script> tags—particularly those without
  an async or defer attribute—block rendering, and pause the parsing of HTML. Though the browser's preload scanner hastens this process, excessive scripts can still be a significant bottleneck.
    ![image](https://user-images.githubusercontent.com/107746743/174861168-f8e5c6ec-c0be-456b-9c57-677c4e233d51.png)
  **# - Order of script processing**
 The model of the web is synchronous. Authors expect scripts to be parsed and executed immediately when the parser reaches a ``<script>`` tag. The parsing of the document halts until the script has been executed. If the script is external then the resource must first be fetched from
  the network - this is also done synchronously, and parsing halts until the resource is fetched. This was the model for many years and is also specified in HTML4 and 5 specifications. Authors can add the "defer" attribute to a script, in which case it will not halt document parsing and will execute after the document is parsed. 
  HTML5 adds an option to mark the script as asynchronous so it will be parsed and executed by a different thread.

  ** #- Layout and painting**
  **Layout** 
Layout is dependent on the size of screen. The layout step determines where and how the elements are positioned on the page, determining the width and height of each element,
 and where they are in relation to each other.
**Paint**
The last step is painting the pixels to the screen. Once the render tree is created and layout occurs, the pixels can be painted to the screen. On load, the entire screen is painted. After that, only impacted areas of the screen will be repainted,
 as browsers are optimized to repaint the minimum area required
